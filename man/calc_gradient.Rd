% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/numericalDifferentiation.R
\name{calc_gradient}
\alias{calc_gradient}
\alias{calc_hessian}
\alias{get_gradient}
\alias{get_hessian}
\alias{get_soc}
\alias{get_foc}
\title{Calculate gradient or Hessian matrix}
\usage{
calc_gradient(x, fn, h = 6e-06, ...)

calc_hessian(x, fn, h = 6e-06, ...)

get_gradient(gmvar, h = 6e-06)

get_hessian(gmvar, h = 6e-06)

get_soc(gmvar, h = 6e-06)

get_foc(gmvar, h = 6e-06)
}
\arguments{
\item{x}{a numeric vector specifying the point where the gradient or Hessian should be calculated.}

\item{fn}{a function that takes in argument \code{x} as the \strong{first} argument.}

\item{h}{difference used to approximate the derivatives.}

\item{...}{other arguments passed to \code{fn}}

\item{gmvar}{an object of class \code{'gmvar'} created with \code{fitGMVAR} or \code{GMVAR}.}
}
\value{
Gradient functions return numerical approximation of the gradient and Hessian functions return
  numerical approximation of the Hessian. \code{get_soc} returns eigenvalues of the Hessian matrix.
}
\description{
\code{calc_gradient} or \code{calc_hessian} calculates the gradient or Hessian matrix
  of the given function at the given point using central difference numerical approximation.
  \code{get_gradient} or \code{get_hessian} calculates the gradient or Hessian matrix of the
  log-likelihood function at the parameter estimates of a class \code{'gmvar'} object. \code{get_soc}
  returns eigenvalues of the Hessian matrix, and \code{get_foc} is the same as \code{get_gradient}
  but named conveniently.
}
\details{
In particular, the functions \code{get_foc} and \code{get_soc} can be used to check whether
  the found estimates denote a (local) maximum point, a saddle point, or something else. Note that
  profile log-likelihood functions can be conveniently plotted with the function \code{profile_logliks}.
}
\section{Warning}{

  No argument checks!
}

\examples{
  # Simple function
  foo <- function(x) x^2 + x
  calc_gradient(x=1, fn=foo)
  calc_gradient(x=-0.5, fn=foo)

  # More complicated function
  foo <- function(x, a, b) a*x[1]^2 - b*x[2]^2
  calc_gradient(x=c(1, 2), fn=foo, a=0.3, b=0.1)

  # These examples below use the data 'eurusd' which comes
  # with the package, but in a scaled form.
  data <- cbind(10*eurusd[,1], 100*eurusd[,2])
  colnames(data) <- colnames(eurusd)

  \donttest{
  # GMVAR(1,2), d=2 model:
  params122 <- c(0.623, -0.129, 0.959, 0.089, -0.006, 1.006, 1.746,
    0.804, 5.804, 3.245, 7.913, 0.952, -0.037, -0.019, 0.943, 6.926,
    3.982, 12.135, 0.789)
  mod122 <- GMVAR(data, p=1, M=2, params=params122)
  get_gradient(mod122)
  get_hessian(mod122)
  get_soc(mod122)
  }
}
\seealso{
\code{\link{profile_logliks}}
}
